#Importations

from scipy import misc
import matplotlib.pyplot as plt
import numpy as np
import os

#Dans la console :
#   os.chdir("")

img=misc.imread("QR du pif.png")



#Contraste

for i in range(img.shape[0]) :
    for j in range(img.shape[1]) :
        for k in range(3) :
            if img[i,j,k]>150 :
                img[i,j,k]=255
            else :
                img[i,j,k]=0



for i in range(img.shape[0]) : #parcours de toutes les lignes
    j=0 #compteur des colonnes
    pix=img[i,j,0]
    preN,derN=0,0
    while j<img.shape[1] and preN==0 :
        if img[i,j,0]==0 :
            preN=[i,j]
        j+=1
    while j<img.shape[1] :
        if img[i,j,0]==0 :
            derN=[i,j]
        j+=1
    if derN!=0 :
        break

lenQR=derN[1]-preN[1]+1
#QRrogne=np.zeros([lenQR,lenQR,3])
#
#for i in range(lenQR) :
#    for j in range(lenQR) :
#        for k in range(3) :
#            #QRrogne[i,j,k]=int(img[i+preN[0],j+preN[1],k])
#            
#plt.imshow(QRrogne)
#plt.show()

QRrogne=img[preN[0]:preN[0]+lenQR,preN[1]:derN[1]+1,:]

plt.imshow(QRrogne)
plt.show()

misc.imsave("QRrogne.jpg",QRrogne)




#7détermination de la taille d'un carré en pixel

#évaluation de la taille en pixel des carrés
j=0
while QRrogne[0,j,0]==0 : #parcours des colonnes
  j+=1
  premB=j#colonne du premier pixel blanc
taillecarre=premB//7#taille d'un carré en pixel

#Détermination de la version
Version=int(((np.shape(QRrogne)[0]/taillecarre-2*8)-1)//4) #longueur du timing pattern -1(car impair) divisé par 4 (http://www-igm.univ-mlv.fr/~dr/XPOSE2011/QRCode/description.html)        Doit être un entier

Tailleversion=Version*4+17


#Création de la matrice QR


MatQR=np.zeros([Tailleversion,Tailleversion],dtype='int') #Création d'une matrice en carré à remplir, en forçant le type des données en nombres entiers
for i in range(Tailleversion) :
    for j in range(Tailleversion) :
        if QRrogne[taillecarre*i,taillecarre*j,0]==0 :
            MatQR[i,j]+=1

#








#Protection des zones non masquées

MatQRsecure=np.copy(MatQR)
for i in range(9) :  #protection des 3 finder patterns
    for j in range(9) :
        MatQRsecure[i,j]+=42 #en haut à gauche
    for j in range(8) :
        MatQRsecure[(Tailleversion)-8+j,i]+=42 #en haut à droite
        MatQRsecure[i,(Tailleversion)-8+j]+=42 #en bas à gauche
for k in range(4*Version) : #protection des 2 timing patterns
    MatQRsecure[6,9+k]+=42 #horizontal
    MatQRsecure[9+k,6]+=42 #vertical
    
#Reference des masques


RefMasque = {  0 :lambda i,j: (i+j)%2 == 0,  1 :lambda i,j: i%2 == 0,  2 :lambda i,j: j%3 == 0,  3 :lambda i,j: (i+j)%3 == 0,  4 :lambda i,j: (i/2+j/3)%2 == 0,  5 :lambda i,j: (i*j)%2+(i*j)%3 == 0,  6 :lambda i,j: ((i*j)%3+i*j)%2 == 0,  7 :lambda i,j: ((i*j)%3+i+j)%2== 0}

FormatMasque=str(int(MatQR[8,4]))+str(int(MatQR[8,3]))+str(int(MatQR[8,2]))
NumMasque=int(FormatMasque,2)

#Démasquage

def inverse(x) :
    return int(x==0)

MatQRdemask=np.copy(MatQRsecure)
for i in range (Tailleversion) :
    for j in range (Tailleversion) :
        if MatQRsecure[i,j]<42 :
            if RefMasque[NumMasque](i,j) :#a corriger controle flux python dictionnaire
                MatQRdemask[i,j]=inverse(MatQRdemask[i,j])


